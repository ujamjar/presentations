---
layout: presentation
title: ORCONF 2015 
description: OCaml and FPGAs
author: Andy Ray
---

<!-- Intro -->

<section data-markdown><script type="text/template">
# OCaml and FPGAs

### ORCONF 2015

Writing hardware in OCaml.  

Running OCaml in hardware.

andy.ray@ujamjar.com
</script></section>

<section data-markdown><script type="text/template">
# Topics

* __HardCaml__ RTL level hardware design as an embedded DSL in Ocaml
* __HardCaml-RISCV__ a simple pipelined RISC-V cpu written in HardCaml
* __HardCaml-ZINC__ extending the RISC-V core to implement the Ocaml ZINC bytecode instruction set
</script></section>

<!-- HardCaml -->

<section>
  <section data-markdown><script type="text/template">
# HardCaml

* Structural RTL design.  
* RTL generation 
* Simulation
  </script></section>

  <section>
    <table>
      <thead>
        <tr>
          <th>Class</th>
          <th>Function</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align:left">arithmetic</td>
          <td style="text-align:left"><code>+: -: *: *+ negate</code></td>
        </tr>
        <tr>
          <td style="text-align:left">logical</td>
          <td style="text-align:left"><code>&amp: ^: ~: |:</code></td>
        </tr>
        <tr>
          <td style="text-align:left">comparison</td>
          <td style="text-align:left"><code>==: <>: &lt: &gt: &lt=: &gt=: &lt+ &gt+ &lt=+ &gt=+</code></td>
        </tr>
        <tr>
          <td style="text-align:left">constants</td>
          <td style="text-align:left"><code>const zero one ones</code></td>
        </tr>
        <tr>
          <td style="text-align:left">mux</td>
          <td style="text-align:left"><code>mux mux2 pmux pmux1h</code></td>
        </tr>
        <tr>
          <td style="text-align:left">bits</td>
          <td style="text-align:left"><code>bit select .[:] concat @: msb lsb</code></td>
        </tr>
        <tr>
          <td style="text-align:left">misc</td>
          <td style="text-align:left"><code>width wire -- &lt==</code></td>
        </tr>
        <tr>
          <td style="text-align:left">sequential</td>
          <td style="text-align:left"><code>reg pipeline memory ram_rbw ram_wbr</code></td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
<h1>Example</h1>

<pre><code class="ocaml">
let fir_filter coefs enable x = 
  let f d coef =
    let q = reg r_sync enable d in
    q, q *+ coef
  in
  let g (d,list) coef = 
    let q, m = f d coef in
    q, m::list
  in
  let _, m = List.fold_left g (x, []) coefs in
  tree 2 (reduce (+:)) m
</code></pre>
  </section>

  <section> 
<pre><code class="ocaml">
  let f d coef = 
    let q = reg r_sync enable d in
    q, q *+ coef
</code></pre>
    <img src="assets/filter1.png">
  </section>
  <section> 
<pre><code class="ocaml">
  let g (d,list) coef = 
    let q, m = f d coef in
    q, m::list
  in
  let _, m = List.fold_left g (x, []) coefs in
</code></pre>
    <img src="assets/filter2.png">
  </section>
  <section> 
<pre><code class="ocaml">
  tree 2 (reduce (+:)) m
</code></pre>
    <img src="assets/filter3.png">
  </section>

</section>

<section>
  <section data-markdown><script type="text/template">
# Layered DSLs

* Build libraries to raise level of abstraction
  </script></section>

  <section data-markdown><script type="text/template">
# Guarded DSL 

## VHDL processes, Verilog always blocks
  </script></section>

  <section data-markdown><script type="text/template">

http://www.asic-world.com/tidbits/verilog_fsm.html

```verilog
  always @ (posedge clock)
   case(state)
     IDLE : 
       if (req_0 == 1'b1) begin
         state <= GNT0;
         gnt_0 <= 1;
       end else if (req_1 == 1'b1) begin
         gnt_1 <= 1;
         state <= GNT1;
       end else begin
         state <=  IDLE;
       end
     GNT0 : 
       if (req_0 == 1'b1) begin
         state <= GNT0;
       end else begin
         gnt_0 <= 0;
         state <= IDLE;
       end
     GNT1 : 
       if (req_1 == 1'b1) begin
         state <= GNT1;
       end else begin
         gnt_1 <= 0;
         state <= IDLE;
       end
     default : state <= IDLE;
   endcase
  end
```
  </script></section>

  <section data-markdown><script type="text/template">
```ocaml
  let () = compile [
    state `idle;
    sm [
      `idle, [
         g_if req_0 [
           state `gnt0;
           gnt_0 $==. 1;
         ] @@ g_elif req_1 [
           gnt_1 $==. 1;
           state `gnt1;
         ] [
           state `idle;
         ]
       ]
     `gnt0, 
       g_if req_0 [
         state `gnt0;
       ] [
         gnt_0 $==. 0;
         state `idle;
       ]
     `gnt1, [
        g_if req_1 [
          state `gnt1;
        ] [
          gnt_1 $==. 0;
          state `idle;
        ]
      ]
    ]
  ]
```
  </script></section>

  <section data-markdown><script type="text/template">
# Recipes 

* monad reader issue 7, A Recipe for controlling Lego using Lava
* Imperative style programming 
* OCCAM like par/seq operations

  </script></section>
  <section data-markdown><script type="text/template">
Psuedo-code

```
par
  a=a_in; 
  b=b_in; 
  acc=0;
while (b != 0) 
  par
    a = a << 1; 
    b = b >> 1; 
    acc = b[0] ? (acc + a) acc;
return acc
```
  </script></section>
  <section data-markdown><script type="text/template">
Monadic OCaml code

```ocaml
  let step s = 
    { a = sll s.a 1; b = srl s.b 1; acc=mux2 (lsb s.b) (s.acc +: s.a) s.acc }

  let mult a_in b_in = 
    perform 
      state <-- newVar();
      apply (fun _ -> { a=a_in; b=b_in; acc=zero 8 }) state;
      SVar.while_ (fun b -> b <>:. 0) state.b 
        (apply step state);
      acc <-- SVar.read state.acc;
      return acc
```
  </script></section>

  <section data-markdown><script type="text/template">
* Predicting the future...
* HardCaml-HLS
  * Imperative style DSL
  * Convert to SSA/Basic blocks
  * Binding, Clique Partitioning etc
  * Generate RTL
* HardCaml-GAA
  * Guarded Atomic Action DSL
  </script></section>
</section>

<section>
  <section data-markdown><script type="text/template">
# Generate RTL

```
let circuit = Circuit.make "toplevel" [ list_of_outputs ]
let () = Rtl.Verilog.write print_string circuit
let () = Rtl.Vhdl.write print_string circuit
```
  </script></section>
  <section data-markdown><script type="text/template">
# Caveat

```
    wire _1214;
    wire _1208;
    wire _1210;
    wire _1216;
    wire _1218;
    wire [31:0] _1219;

    assign _1209 = reg_op1 + reg_op2;
    assign _1207 = reg_op1 - reg_op2;
    assign _1215 = _1210 ? _1209 : _1207;
    assign _1172 = reg_op1 == reg_op2;
    assign _1169 = reg_op1 == reg_op2;
    assign _1170 = ~ _1169;
    assign _1178 = _1173 ? _1172 : _1170;
    assign _1158 = reg_op2[30:0];
    assign _1159 = reg_op2[31:31];
    assign _1160 = ~ _1159;
    assign _1161 = { _1160, _1158 };
    assign _1162 = reg_op1[30:0];
    assign _1163 = reg_op1[31:31];
    assign _1164 = ~ _1163;
    assign _1165 = { _1164, _1162 };
    assign _1166 = _1165 < _1161;
    assign _1167 = ~ _1166;
    assign _1155 = reg_op1 < reg_op2;
    assign _1156 = ~ _1155;
    assign _1176 = _1168 ? _1167 : _1156;
    assign _1180 = _1179 ? _1178 : _1176;
    assign _1145 = reg_op2[30:0];
```
  </script></section>
</section>

<section>
  <section data-markdown><script type="text/template">
# Simulation

* Cycle accurate simulation in OCaml

```
module Sim = HardCaml.Cyclesim.Make(B)
let testbench () = 
  let sim = Sim.make circuit in
  clr := B.vdd;
  S.cycle sim;
  clr := B.gnd;
  ena := B.vdd;
  d := B.consti 32 12;
  S.cycle sim;
  printf "%i\n" (B.to_int !q);
```
  </script></section>
  <section data-markdown><script type="text/template">
# HardCaml-LLVMSIM

* Same API 
* __Much__ faster

```
module Sim = HardCamlLlvmsim.Sim.Make(B)
let () = testbench ()
```
  </script></section>
  <section data-markdown><script type="text/template">
# HardCaml-VPI

* Simulation performed by Icarus Verilog
* Same API
* Generates Verilog + testbench
* Interacts with OCaml testbench through a VPI object over sockets

```
module Sim = HardCaml.Cosim.Make(B)
let () = testbench ()
```
  </script></section>

  <section data-markdown><script type="text/template">
# HardCaml-waveterm

* Waveforms rendered in unicode
* Interactive terminal version

```
┌Signals─┐┌Values──┐┌Waves─────────────────────────────────────────────────────┐
│clock   ││        ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌─│
│        ││        ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───┘ │
│a       ││0       ││                ┌───────┐       ┌───────┐               ┌─│
│        ││        ││────────────────┘       └───────┘       └───────────────┘ │
│        ││        ││────────┬───────┬───────┬───────┬───────┬───────┬───────┬─│
│b       ││-318    ││ -318   │-131   │387    │-33    │-69    │-5     │-463   │3│
│        ││        ││────────┴───────┴───────┴───────┴───────┴───────┴───────┴─│
│c       ││0       ││                ┌───────────────┐                       ┌─│
│        ││        ││────────────────┘               └───────────────────────┘ │
│        ││        ││────────────────┬───────┬───────┬───────┬───────┬───────┬─│
│gamma-om││1       ││ 1              │9      │8      │4      │6      │5      │0│
│        ││        ││────────────────┴───────┴───────┴───────┴───────┴───────┴─│
│        ││        ││────────┬───────┬───────┬───────────────────────────────┬─│
│beta    ││0       ││ 0      │2      │1      │0                              │2│
│        ││        ││────────┴───────┴───────┴───────────────────────────────┴─│
│delta   ││1       ││────────┐       ┌───────┐       ┌───────┐       ┌───────┐ │
│        ││        ││        └───────┘       └───────┘       └───────┘       └─│
│eye     ││0       ││        ┌───────┐                               ┌─────────│
│        ││        ││────────┘       └───────────────────────────────┘         │
└────────┘└────────┘└──────────────────────────────────────────────────────────┘
```
  </script></section>

</section>

<section data-markdown><script type="text/template">
# Javascript

* Excellent OCaml to javascript compiler; [js_of_ocaml](https://github.com/ocsigen/js_of_ocaml)
* HardCaml web apps 
  * configure, simulate and generate cores 
  * All in browser 
* See also the [IOCamlJS](https://github.com/andrewray/iocamljs) based HardCaml [documentation](http://www.ujamjar.com/hardcaml)
</script></section>

<section>
  <section data-markdown><script type="text/template">
# Some details

* Type representing _combinatorial hardware_ can be shallow or deep
* Shallow
  * Hardware represented as values ie int list
  * Great for exploring combinatorial logic in REPL
* Deep
  * Hardware represented as an AST.  
  * Required for simulation or RTL generation
* Only deep embedding for sequential logic
  </script></section>

  <section data-markdown><script type="text/template">
# Shallow

```
        OCaml version 4.02.1

# #use "topfind";;
# #require "hardcaml";;
# open HardCaml.Api.B;;
# (const "01") +: (const "10");;
- : HardCaml.Api.B.t = [1; 1]
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : HardCaml.Api.B.t = [0; 0; 0; 1; 0; 0; 0; 0]
```
  </script></section>

  <section data-markdown><script type="text/template">
# Deep

```
# open HardCaml.Api.Comb;;
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : HardCaml.Api.Comb.t =
HardCaml.Signal.Types.Signal_op
 ({HardCaml.Signal.Types.s_id = 43L; s_names = []; s_width = 8;
   s_deps =
    [HardCaml.Signal.Types.Signal_op
      ({HardCaml.Signal.Types.s_id = 42L; s_names = []; s_width = 8;
        s_deps =
         [HardCaml.Signal.Types.Signal_op
           ({HardCaml.Signal.Types.s_id = 41L; s_names = []; s_width = 8;
             s_deps =
              [HardCaml.Signal.Types.Signal_const
                ({HardCaml.Signal.Types.s_id = 37L; s_names = [];
                  s_width = 8; s_deps = []},
                "00000001");
               HardCaml.Signal.Types.Signal_const
                ({HardCaml.Signal.Types.s_id = 38L; s_names = [];
                  s_width = 8; s_deps = []},
                "00000010")]},
           HardCaml.Signal.Types.Signal_add);
          HardCaml.Signal.Types.Signal_const
           ({HardCaml.Signal.Types.s_id = 39L; s_names = []; s_width = 8;
             s_deps = []},
           "00000011")]},
      HardCaml.Signal.Types.Signal_add);
     HardCaml.Signal.Types.Signal_const
      ({HardCaml.Signal.Types.s_id = 40L; s_names = []; s_width = 8;
        s_deps = []},
      "00001010")]},
 HardCaml.Signal.Types.Signal_add)
```
  </script></section>

  <section data-markdown><script type="text/template">
# Xilinx LUTs

* Same code, different functors, very different results.

```
# open HardCaml.Xilinx;;
# module X = HardCaml.Comb.Make( XComb( XMake(Unisim)(Lut4) ) );;
# open X;;
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : X.t =
HardCaml.Signal.Types.Signal_op
 ({HardCaml.Signal.Types.s_id = 610L; s_names = []; s_width = 8;
   s_deps =
    [HardCaml.Signal.Types.Signal_inst
      ({HardCaml.Signal.Types.s_id = 607L; s_names = []; s_width = 1;
        s_deps =
        ...
```

* Looks like the deep embedding
  </script></section>

  <section data-markdown><script type="text/template">
* Write to Verilog

```
# HardCaml.Rtl.Verilog.write print_string @@ 
    HardCaml.Circuit.make "xadd" 
    [ output "q" (reduce (+:) (List.map (consti 8) [1;2;3;10])) ];;
...
    assign _810 = _809[0:0];
    LUT2
        #( .INIT("0110") )
        the_LUT2_22
        ( .I0(_810), .I1(_811), .O(_813[0:0]) );
    assign _793 = _614[0:0];
    MUXCY
        the_MUXCY_13
        ( .CI(gnd), .DI(_793), .S(_813), .O(_817[0:0]) );
...
```
  </script></section>

</section>

<!-- HardCaml-RISCV -->

<section data-markdown><script type="text/template">
# HardCaml-RISCV

Pretty basic RISC-V processor implemented in HardCaml
</script></section>

<section>

  <section data-markdown><script type="text/template">
# Status

* RV32I only
* Simple 5 stage pipeline
* Targetted at FPGA technology
* Instruction and data caches
  </script></section>

  <section data-markdown><script type="text/template">
# Near term Plans

* RV64I
* M extension
* C extension
* Extended pipeline (thinking 7 stage) with branch predictor
  </script></section>

  <section data-markdown><script type="text/template">
# Longer term plans

* Virtual memory
* Supervisor spec
* Easily configurable instruction set
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# Instruction decoding - TRAP

* RISC-V must trap on illegal instruction
* How can we be confident of that with a hand written instruction decoder?
* Enumeration (brute force) out of the question
* Solution; SAT solver
  </script></section>

  <section data-markdown><script type="text/template">
# SAT

* We have an implementation we want to test; h(i)
* We need an implementation we can trust; t(i)
* Now we need to ask a question.
 * Are these things the same? h(i) = t(i)
 * Are these things different? h(i) <> t(i)
* We ask the 2nd question;
 * SAT; they are different and we get a bit pattern that causes a problem
 * UNSAT; they are not different!
  </script></section>

  <section data-markdown><script type="text/template">
# Trusted implementation

* https://github.com/riscv/riscv-opcodes
* Parse and convert into mask/match pairs
 * mask - remove immediates, register specifiers
 * match - check bits relevant to decode
 * f(i,j) = (i & mask<sub>j</sub>) == match<sub>j</sub>
* trap = !(f(i,0) | f(i,1) | ... | f(i,47))
  </script></section>

  <section data-markdown><script type="text/template">
```
(* trusted implementation *)
module Ref = struct
  let insn = 
    let x = List.map (fun x -> List.assoc x Riscv.RV32I.T.mask_match) Insn.V.list in
    let open B in
    let f (mask,mat) = (instr &: (consti32 32 mask)) ==: consti32 32 mat in
    let insn = List.map f x in
    let trap = ~: (reduce (|:) insn) in
    B.concat (trap :: List.rev insn)
end
```
  </script></section>

  <section data-markdown><script type="text/template">
# HardCaml-bloop

* https://www.coursera.org/course/vlsicad
* PCN, Kmap, CNF, DNF, BDD, SAT
* Convert HardCaml API to/from various formats
* Linear expansion from gates to CNF

```
Fadi Aloul, Igor L. Markov, Karem Sakallah, “MINCE: A Static Global Variable-Ordering Heuristic for
SAT Search and BDD Manipulation,” J. of Universal Computer Sci., vol. 10, no. 12 (2004), 1562-1596.
```
  </script></section>

  <section data-markdown><script type="text/template">
# Putting it together

HardCamlBloop Comb API

```
module B = HardCamlBloop.Gates.Comb
```

RTL version (look, more functors)

```
module Rtl = struct
  module I = Decoder.Make_insn_decoder(Ifs)(B)
  let insn = I.((decoder instr).insn) 
end
```

Run the solver

```
let insn_ok = B.(Rtl.insn <>: Ref.insn)
let ok = HardCamlBloop.Sat.(report @@ of_signal insn_ok)
```
  </script></section>
</section>

<!-- HardCaml-ZINC -->

<section data-markdown><script type="text/template">
# HardCaml-ZINC

* Extends work on HardCaml-RISCV
* Aims to run OCaml efficiently on FPGA
</script></section>

<section>

  <section data-markdown><script type="text/template">
# Interesting OCaml projects

* MirageOS
* OCaml-TLS
* Multi-core
  </script></section>

  <section data-markdown><script type="text/template">
# MirageOS

https://mirage.io/

<blockquote>
MirageOS is a library operating system that constructs unikernels for secure, high-performance network applications across a variety of cloud computing and mobile platforms. Code can be developed on a normal OS such as Linux or MacOS X, and then compiled into a fully-standalone, specialised unikernel that runs under the Xen hypervisor.
</blockquote>
  </script></section>

  <section data-markdown><script type="text/template">
# OCaml-TLS

https://github.com/mirleft/ocaml-tls

<blockquote>
Our main reasons for ocaml-tls are that OCaml is a modern functional language, which allows concise and declarative descriptions of the complex protocol logic and provides type safety and memory safety to help guard against programming errors. Its functional nature is extensively employed in our code: the core of the protocol is written in purely functional style, without any side effects.
</blockquote>
  </script></section>

  <section data-markdown><script type="text/template">
# OCaml-multicore

http://www.cl.cam.ac.uk/~sd601/papers/multicore_slides.pdf

* Uses an interesting memory heirarchy that we _may_ be able to exploit to reduce hardware complexity
  * Local minor heaps, stacks
  * Global major heap
* Bytecode only at the moment
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# OCaml compiler

* Two types of backend target
  * Byte code
  * Native code 
    * x86, arm, powerpc, sparc
    * risc-v ...
  </script></section>

  <section data-markdown><script type="text/template">
# Byte code

| 31..8 | 7..0 |
|:-|:-|
| 000...000 | bytecode |

* Word code?
* Interleaved with 32 bit arguments
  </script></section>

  <section data-markdown><script type="text/template">
# ZINC stack machine

* Stack based architecture with a few registers (sp, accu, pc, extra_args etc)

```
loop:
  switch (program[pc++]) {
  case PUSH: ... goto loop;
  case POP: ... goto loop;
  }
```
  </script></section>

  <section data-markdown><script type="text/template">
# Performance

* Byte code around 10x slower than native code.  Why?

```
valgrind --tool=cachegrind --branch-sim=yes ./testbench_rv32.{byte,native}
```

Byte code

```
==30498== Branches: 149,126,010 ( 58,921,015 cond + 90,204,995 ind)
==30498== Mispredicts: 88,396,096 ( 1,427,839 cond + 86,968,257 ind)
==30498== Mispred rate: 59.2% ( 2.4% + 96.4% )
```

Native code

```
==30504== Branches: 32,255,824 (30,301,629 cond + 1,954,195 ind)
==30504== Mispredicts: 1,316,445 ( 998,148 cond + 318,297 ind)
==30504== Mispred rate: 4.0% ( 3.2% + 16.2% )
```
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# Instruction set extension

* Conceptually

| 31..24 | 23..6 | 6..0 |
|:-|:-|:-|
| bytecode | 000...000 | opcode |
  </script></section>

  <section data-markdown><script type="text/template">
* Decoded as part of the RISC-V instruction set
* Basic implementation; The bytecode is an immediate and the risc-v instructions causes a jump to 'base + bytecode<<n'
* Indexes into a tightly coupled memory (or ROM) that implements the ocaml bytecode instructions.
* Only the bytecode instructions in Icache, could effectively use a branch predictor.
* Sort of like microcode – but these instructions have real addresses so we can still take precise exceptions.
  </script></section>

  <section data-markdown><script type="text/template">
# Reality

* Considering branch/bound style logical address spaces
* Set up area of memory where byte code instructions reside
* Translated as loaded from icache

# Otherwise

* Rewrite in ocaml compiler
* Rewrite as loaded by runtime
* Rewrite dynamically as executed like a jit
  </script></section>

  <section data-markdown><script type="text/template">
# More extensions

* Tried to solve the interpreter overhead problem
* Other extensions possible
  * `add.zinc rd, rs1, rs2`
  * does GC bit masking in hardware.  Requires minor alterations to ALU.
  * Used in the microcode implementation of bytecode instruction.
  </script></section>

  <section data-markdown><script type="text/template">
# More extensions

* Add new architectural state - top of stack
  * `add.zinc`
  * No operands - reads top of stack and accu implicitly, writes accu
  * No need to call into microcode - just a single cycle instruction
  * Other similar stack accessing ops
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# Why not native code?

* Dynamic loading
* Compiler-libs
* REPL
* Bytecode part of OCaml compiler simpler than native code
  </script></section>

  <section data-markdown><script type="text/template">
# How about native code

* Can reuse some of the instruction set extensions mentioned
* Maybe there's a fast FPGA style architecture waiting to be found
  </script></section>

</section>

<section data-markdown><script type="text/template">
# License and packaging

* License?  BSD 
* Code is released using [OPAM](https://opam.ocaml.org)
* When will it be ready?  When its available in OPAM.
* I want it now!

```
$ opam pin add hardcaml-riscv https://github.com/ujamjar/hardcaml-riscv
$ opam install hardcaml-riscv
```

* Coming soon - fusesoc based systems
</script></section>

<section>

  <section data-markdown><script type="text/template">
# Thanks! Questions?

http://www.ujamjar.com/presentations/orconf2015.html

https://github.com/ujamjar/hardcaml

https://github.com/ujamjar/hardcaml-riscv

https://github.com/ujamjar/hardcaml-zinc

https://github.com/ujamjar/hardcaml-bloop

https://github.com/ujamjar/hardcaml-waveterm

https://github.com/ujamjar/hardcaml-llvmsim

https://github.com/ujamjar/hardcaml-vpi

  </script></section>

</section>

