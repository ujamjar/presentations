---
layout: presentation
title: ORCONF 2015 
description: OCaml and FPGAs
author: Andy Ray
---

<!-- Intro -->

<section data-markdown><script type="text/template">
# OCaml and FPGAs

### ORCONF 2015

Writing hardware in OCaml.  

Running OCaml in hardware.

andy.ray@ujamjar.com
</script></section>

<section data-markdown><script type="text/template">
# Topics

* __HardCaml__ RTL level hardware design as an embedded DSL in Ocaml
* __HardCaml-RISCV__ a simple pipelined RISC-V cpu written in HardCaml
* __HardCaml-ZINC__ extending the RISC-V core to implement the Ocaml ZINC bytecode instruction set
</script></section>

<!-- HardCaml -->

<section>
  <section data-markdown><script type="text/template">
# HardCaml

* Structural RTL design.  
* RTL generation 
* Simulation
  </script></section>

  <section>
    <table>
      <thead>
        <tr>
          <th>Class</th>
          <th>Function</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align:left">arithmetic</td>
          <td style="text-align:left"><code>+: -: *: *+ negate</code></td>
        </tr>
        <tr>
          <td style="text-align:left">logical</td>
          <td style="text-align:left"><code>&amp: ^: ~: |:</code></td>
        </tr>
        <tr>
          <td style="text-align:left">comparison</td>
          <td style="text-align:left"><code>==: <>: &lt: &gt: &lt=: &gt=: &lt+ &gt+ &lt=+ &gt=+</code></td>
        </tr>
        <tr>
          <td style="text-align:left">constants</td>
          <td style="text-align:left"><code>const zero one ones</code></td>
        </tr>
        <tr>
          <td style="text-align:left">mux</td>
          <td style="text-align:left"><code>mux mux2 pmux pmux1h</code></td>
        </tr>
        <tr>
          <td style="text-align:left">bits</td>
          <td style="text-align:left"><code>bit select .[:] concat @: msb lsb</code></td>
        </tr>
        <tr>
          <td style="text-align:left">misc</td>
          <td style="text-align:left"><code>width wire -- &lt==</code></td>
        </tr>
        <tr>
          <td style="text-align:left">sequential</td>
          <td style="text-align:left"><code>reg pipeline memory ram_rbw ram_wbr</code></td>
        </tr>
      </tbody>
    </table>
  </section>

  <section data-markdown><script type="text/template">
* Derive new types

```
type complex = { re : signal; im : signal }

let complex_multiply a b = {
  re = (a.re *+ b.re) -: (a.im *+ b.im);
  im = (a.re *+ b.im) +: (a.im *+ b.re);
}
```
  </script></section>

  <section data-markdown><script type="text/template">
* Higher order functions

```
let fir_filter taps enable x = 
  let f (p,v) tap = 
    let p = reg r_sync enable p in
    p, (p *: tap)::v
  in
  let x = snd @@ List.fold_left f (x, []) taps in
  tree 2 (reduce (+:) x)
```
  </script></section>

</section>

<section>
  <section data-markdown><script type="text/template">
# Layered DSLs

* Build libraries to raise level of abstraction
  </script></section>

  <section data-markdown><script type="text/template">
* Guarded DSL - VHDL processes, Verilog always blocks
```
  let () = compile [
    sm [
      `wait, [
        cnt $==. (-1);
        msel $==. 0;
        g_when i.miss [
          msel $==. 1;
          maddr $== aligned_addr i.addr;
          caddr $== aligned_addr i.addr;
          g_if i.rw [
            (* read - load new cache line *)
            mreq $==. 1;
            next `load;
          ] [
            (* write *)
            g_if i.dirty [
              (* current cache line needs to be flushed *)
              maddr $== aligned_addr i.evict_addr;
  ....
```
  </script></section>

  <section data-markdown><script type="text/template">
* Recipes (monad reader issue 7, A Recipe for controlling Lego using Lava)

```
  let mult a_in b_in = 
    let open State in
    perform 
      (* create registers *)
      state <-- SState.newVar();
      (* set inputs and clear accumulator *)
      SState.apply (fun _ -> { a=a_in; b=b_in; acc=zero 8 }) state;
      (* serial multiplier *)
      SVar.while_ (fun b -> b <>:. 0) state.b 
        SState.(apply step state);
      (* return output *)
      acc <-- SVar.read state.acc;
      return acc
```
  </script></section>
  <section data-markdown><script type="text/template">
* Predicting the future...
* HardCaml-HLS
 * Imperative style DSL
 * Convert to SSA/Basic blocks
 * Binding, Clique Partitioning etc
 * Generate RTL
* HardCaml-GAA
 * Guarded Atomic Action DSL
  </script></section>
</section>

<section>
  <section data-markdown><script type="text/template">
# Generate RTL

```
let circuit = Circuit.make "toplevel" [ list_of_outputs ]
let () = Rtl.Verilog.write print_string circuit
let () = Rtl.Vhdl.write print_string circuit
```
  </script></section>
  <section data-markdown><script type="text/template">
# Caveat

```
    wire _1214;
    wire _1208;
    wire _1210;
    wire _1216;
    wire _1218;
    wire [31:0] _1219;

    assign _1209 = reg_op1 + reg_op2;
    assign _1207 = reg_op1 - reg_op2;
    assign _1215 = _1210 ? _1209 : _1207;
    assign _1172 = reg_op1 == reg_op2;
    assign _1169 = reg_op1 == reg_op2;
    assign _1170 = ~ _1169;
    assign _1178 = _1173 ? _1172 : _1170;
    assign _1158 = reg_op2[30:0];
    assign _1159 = reg_op2[31:31];
    assign _1160 = ~ _1159;
    assign _1161 = { _1160, _1158 };
    assign _1162 = reg_op1[30:0];
    assign _1163 = reg_op1[31:31];
    assign _1164 = ~ _1163;
    assign _1165 = { _1164, _1162 };
    assign _1166 = _1165 < _1161;
    assign _1167 = ~ _1166;
    assign _1155 = reg_op1 < reg_op2;
    assign _1156 = ~ _1155;
    assign _1176 = _1168 ? _1167 : _1156;
    assign _1180 = _1179 ? _1178 : _1176;
    assign _1145 = reg_op2[30:0];
```
  </script></section>
</section>

<section>
  <section data-markdown><script type="text/template">
# Simulation

* Cycle accurate simulation in OCaml

```
module Sim = HardCaml.Cyclesim.Make(B)
let testbench () = 
  let sim = Sim.make circuit in
  clr := B.vdd;
  S.cycle sim;
  clr := B.gnd;
  ena := B.vdd;
  d := B.consti 32 12;
  S.cycle sim;
  printf "%i\n" (B.to_int !q);
```
  </script></section>
  <section data-markdown><script type="text/template">
# HardCaml-LLVMSIM

* Same API 
* __Much__ faster

```
module Sim = HardCamlLlvmsim.Sim.Make(B)
let () = testbench ()
```
  </script></section>
  <section data-markdown><script type="text/template">
# HardCaml-VPI

* Simulation performed by Icarus Verilog
* Same API
* Generates Verilog + testbench
* Interacts with OCaml testbench through a VPI object over sockets

```
module Sim = HardCaml.Cosim.Make(B)
let () = testbench ()
```
  </script></section>

  <section data-markdown><script type="text/template">
# HardCaml-waveterm

* Waveforms rendered in unicode
* Interactive terminal version

```
┌Signals─┐┌Values──┐┌Waves─────────────────────────────────────────────────────┐
│clock   ││        ││┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌───┐   ┌─│
│        ││        ││    └───┘   └───┘   └───┘   └───┘   └───┘   └───┘   └───┘ │
│a       ││0       ││                ┌───────┐       ┌───────┐               ┌─│
│        ││        ││────────────────┘       └───────┘       └───────────────┘ │
│        ││        ││────────┬───────┬───────┬───────┬───────┬───────┬───────┬─│
│b       ││-318    ││ -318   │-131   │387    │-33    │-69    │-5     │-463   │3│
│        ││        ││────────┴───────┴───────┴───────┴───────┴───────┴───────┴─│
│c       ││0       ││                ┌───────────────┐                       ┌─│
│        ││        ││────────────────┘               └───────────────────────┘ │
│        ││        ││────────────────┬───────┬───────┬───────┬───────┬───────┬─│
│gamma-om││1       ││ 1              │9      │8      │4      │6      │5      │0│
│        ││        ││────────────────┴───────┴───────┴───────┴───────┴───────┴─│
│        ││        ││────────┬───────┬───────┬───────────────────────────────┬─│
│beta    ││0       ││ 0      │2      │1      │0                              │2│
│        ││        ││────────┴───────┴───────┴───────────────────────────────┴─│
│delta   ││1       ││────────┐       ┌───────┐       ┌───────┐       ┌───────┐ │
│        ││        ││        └───────┘       └───────┘       └───────┘       └─│
│eye     ││0       ││        ┌───────┐                               ┌─────────│
│        ││        ││────────┘       └───────────────────────────────┘         │
└────────┘└────────┘└──────────────────────────────────────────────────────────┘
```
  </script></section>

</section>

<section data-markdown><script type="text/template">
# Javascript

* OCaml has an excellent compiler to javascript; [js_of_ocaml](https://github.com/ocsigen/js_of_ocaml)
* Therefore, HardCaml can be compiled to javascript too.
* HardCaml web apps can configure, simulate and generate ip cores in the browser.  No server side magic needed.
* See also the [IOCamlJS](https://github.com/andrewray/iocamljs) based HardCaml [documentation](http://www.ujamjar.com/hardcaml)
</script></section>

<section>
  <section data-markdown><script type="text/template">
# Some details

* Type representing _combinatorial hardware_ can be shallow or deep
* Shallow
  * Hardware represented as values ie int list
  * Great for exploring combinatorial logic in REPL
* Deep
  * Hardware represented as an AST.  
  * Required for simulation or RTL generation
* Only deep embedding for sequential logic
  </script></section>

  <section data-markdown><script type="text/template">
# Shallow

```
        OCaml version 4.02.1

# #use "topfind";;
# #require "hardcaml";;
# open HardCaml.Api.B;;
# (const "01") +: (const "10");;
- : HardCaml.Api.B.t = [1; 1]
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : HardCaml.Api.B.t = [0; 0; 0; 1; 0; 0; 0; 0]
```
  </script></section>

  <section data-markdown><script type="text/template">
# Deep

```
# open HardCaml.Api.Comb;;
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : HardCaml.Api.Comb.t =
HardCaml.Signal.Types.Signal_op
 ({HardCaml.Signal.Types.s_id = 43L; s_names = []; s_width = 8;
   s_deps =
    [HardCaml.Signal.Types.Signal_op
      ({HardCaml.Signal.Types.s_id = 42L; s_names = []; s_width = 8;
        s_deps =
         [HardCaml.Signal.Types.Signal_op
           ({HardCaml.Signal.Types.s_id = 41L; s_names = []; s_width = 8;
             s_deps =
              [HardCaml.Signal.Types.Signal_const
                ({HardCaml.Signal.Types.s_id = 37L; s_names = [];
                  s_width = 8; s_deps = []},
                "00000001");
               HardCaml.Signal.Types.Signal_const
                ({HardCaml.Signal.Types.s_id = 38L; s_names = [];
                  s_width = 8; s_deps = []},
                "00000010")]},
           HardCaml.Signal.Types.Signal_add);
          HardCaml.Signal.Types.Signal_const
           ({HardCaml.Signal.Types.s_id = 39L; s_names = []; s_width = 8;
             s_deps = []},
           "00000011")]},
      HardCaml.Signal.Types.Signal_add);
     HardCaml.Signal.Types.Signal_const
      ({HardCaml.Signal.Types.s_id = 40L; s_names = []; s_width = 8;
        s_deps = []},
      "00001010")]},
 HardCaml.Signal.Types.Signal_add)
```
  </script></section>

  <section data-markdown><script type="text/template">
# Xilinx LUTs

* Same code, different functors, very different results.

```
# open HardCaml.Xilinx;;
# module X = HardCaml.Comb.Make( XComb( XMake(Unisim)(Lut4) ) );;
# open X;;
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : X.t =
HardCaml.Signal.Types.Signal_op
 ({HardCaml.Signal.Types.s_id = 610L; s_names = []; s_width = 8;
   s_deps =
    [HardCaml.Signal.Types.Signal_inst
      ({HardCaml.Signal.Types.s_id = 607L; s_names = []; s_width = 1;
        s_deps =
        ...
# HardCaml.Rtl.Verilog.write print_string @@ 
    HardCaml.Circuit.make "xadd" 
    [ output "q" (reduce (+:) (List.map (consti 8) [1;2;3;10])) ];;
...
    assign _810 = _809[0:0];
    LUT2
        #( .INIT("0110") )
        the_LUT2_22
        ( .I0(_810), .I1(_811), .O(_813[0:0]) );
    assign _793 = _614[0:0];
    MUXCY
        the_MUXCY_13
        ( .CI(gnd), .DI(_793), .S(_813), .O(_817[0:0]) );
...
```
  </script></section>

</section>

<!-- HardCaml-RISCV -->

<section data-markdown><script type="text/template">
# HardCaml-RISCV

Pretty basic RISC-V processor implemented in HardCaml
</script></section>

<section>

  <section data-markdown><script type="text/template">
# Status

* RV32I only
* Simple 5 stage pipeline
* Targetted at FPGA technology
* Instruction and data caches
  </script></section>

  <section data-markdown><script type="text/template">
# Near term Plans

* RV64I
* M extension
* C extension
* Extended pipeline (thinking 7 stage) with branch predictor
  </script></section>

  <section data-markdown><script type="text/template">
# Longer term plans

* Virtual memory
* Supervisor spec
* Easily configurable instruction set
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# Instruction decoding - TRAP

* RISC-V must trap on illegal instruction
* How can we be confident of that with a hand written instruction decoder?
* Enumeration (brute force) out of the question
* Solution; SAT solver
  </script></section>

  <section data-markdown><script type="text/template">
# SAT

* We have an implementation we want to test; h(i)
* We need an implementation we can trust; t(i)
* Now we need to ask a question.
 * Are these things the same? h(i) = t(i)
 * Are these things different? h(i) <> t(i)
* We ask the 2nd question;
 * SAT; they are different and we get a bit pattern that causes a problem
 * UNSAT; they are not different!
  </script></section>

  <section data-markdown><script type="text/template">
# Trusted implementation

* https://github.com/riscv/riscv-opcodes
* Parse and convert into mask/match pairs
 * mask - remove immediates, register specifiers
 * match - check bits relevant to decode
 * f(i,j) = (i & mask<sub>j</sub>) == match<sub>j</sub>
* trap = !(f(i,0) | f(i,1) | ... | f(i,47))
  </script></section>

  <section data-markdown><script type="text/template">
```
(* trusted implementation *)
module Ref = struct
  let insn = 
    let x = List.map (fun x -> List.assoc x Riscv.RV32I.T.mask_match) Insn.V.list in
    let open B in
    let f (mask,mat) = (instr &: (consti32 32 mask)) ==: consti32 32 mat in
    let insn = List.map f x in
    let trap = ~: (reduce (|:) insn) in
    B.concat (trap :: List.rev insn)
end
```
  </script></section>

  <section data-markdown><script type="text/template">
# HardCaml-bloop

* https://www.coursera.org/course/vlsicad
* PCN, Kmap, CNF, DNF, BDD, SAT
* Convert HardCaml API to/from various formats
* Linear expansion from gates to CNF

```
Fadi Aloul, Igor L. Markov, Karem Sakallah, “MINCE: A Static Global Variable-Ordering Heuristic for
SAT Search and BDD Manipulation,” J. of Universal Computer Sci., vol. 10, no. 12 (2004), 1562-1596.
```
  </script></section>

  <section data-markdown><script type="text/template">
# Putting it together

HardCamlBloop Comb API

```
module B = HardCamlBloop.Gates.Comb
```

RTL version (look, more functors)

```
module Rtl = struct
  module I = Decoder.Make_insn_decoder(Ifs)(B)
  let insn = I.((decoder instr).insn) 
end
```

Run the solver

```
let insn_ok = B.(Rtl.insn <>: Ref.insn)
let ok = HardCamlBloop.Sat.(report @@ of_signal insn_ok)
```
  </script></section>
</section>

<!-- HardCaml-ZINC -->

<section data-markdown><script type="text/template">
# HardCaml-ZINC

* Extends work on HardCaml-RISCV
* Aims to run OCaml efficiently on FPGA
</script></section>

<section>

  <section data-markdown><script type="text/template">
# Interesting OCaml projects

* MirageOS
* OCaml-TLS
* Multi-core
  </script></section>

  <section data-markdown><script type="text/template">
# MirageOS

https://mirage.io/

<blockquote>
MirageOS is a library operating system that constructs unikernels for secure, high-performance network applications across a variety of cloud computing and mobile platforms. Code can be developed on a normal OS such as Linux or MacOS X, and then compiled into a fully-standalone, specialised unikernel that runs under the Xen hypervisor.
</blockquote>
  </script></section>

  <section data-markdown><script type="text/template">
# OCaml-TLS

https://github.com/mirleft/ocaml-tls

<blockquote>
Our main reasons for ocaml-tls are that OCaml is a modern functional language, which allows concise and declarative descriptions of the complex protocol logic and provides type safety and memory safety to help guard against programming errors. Its functional nature is extensively employed in our code: the core of the protocol is written in purely functional style, without any side effects.
</blockquote>
  </script></section>

  <section data-markdown><script type="text/template">
# OCaml-multicore

http://www.cl.cam.ac.uk/~sd601/papers/multicore_slides.pdf

* Uses an interesting memory heirarchy that we _may_ be able to exploit to reduce hardware complexity
  * Local minor heaps, stacks
  * Global major heap
* Bytecode only at the moment
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# OCaml compiler

* Two types of backend target
  * Byte code
  * Native code 
    * x86, arm, powerpc, sparc
    * risc-v ...
  </script></section>

  <section data-markdown><script type="text/template">
# Byte code

| 31..8 | 7..0 |
|:-|:-|
| 000...000 | bytecode |

* Word code?
* Interleaved with 32 bit arguments
  </script></section>

  <section data-markdown><script type="text/template">
# ZINC stack machine

* Stack based architecture with a few registers (sp, accu, pc, extra_args etc)

```
loop:
  switch (program[pc++]) {
  case PUSH: ... goto loop;
  case POP: ... goto loop;
  }
```
  </script></section>

  <section data-markdown><script type="text/template">
# Performance

* Byte code around 10x slower than native code.  Why?

```
valgrind --tool=cachegrind --branch-sim=yes ./testbench_rv32.{byte,native}
```

Byte code

```
==30498== Branches: 149,126,010 ( 58,921,015 cond + 90,204,995 ind)
==30498== Mispredicts: 88,396,096 ( 1,427,839 cond + 86,968,257 ind)
==30498== Mispred rate: 59.2% ( 2.4% + 96.4% )
```

Native code

```
==30504== Branches: 32,255,824 (30,301,629 cond + 1,954,195 ind)
==30504== Mispredicts: 1,316,445 ( 998,148 cond + 318,297 ind)
==30504== Mispred rate: 4.0% ( 3.2% + 16.2% )
```
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# Instruction set extension

* Conceptually

| 31..24 | 23..6 | 6..0 |
|:-|:-|:-|
| bytecode | 000...000 | opcode |
  </script></section>

  <section data-markdown><script type="text/template">
* Decoded as part of the RISC-V instruction set
* Basic implementation; The bytecode is an immediate and the risc-v instructions causes a jump to 'base + bytecode<<n'
* Indexes into a tightly coupled memory (or ROM) that implements the ocaml bytecode instructions.
* Only the bytecode instructions in Icache, could effectively use a branch predictor.
* Sort of like microcode – but these instructions have real addresses so we can still take precise exceptions.
  </script></section>

  <section data-markdown><script type="text/template">
# Reality

* Considering branch/bound style logical address spaces
* Set up area of memory where byte code instructions reside
* Translated as loaded from icache

# Otherwise

* Rewrite in ocaml compiler
* Rewrite as loaded by runtime
* Rewrite dynamically as executed like a jit
  </script></section>

  <section data-markdown><script type="text/template">
# More extensions

* Tried to solve the interpreter overhead problem
* Other extensions possible
  * `add.zinc rd, rs1, rs2`
  * does GC bit masking in hardware.  Requires minor alterations to ALU.
  * Used in the microcode implementation of bytecode instruction.
  </script></section>

  <section data-markdown><script type="text/template">
# More extensions

* Add new architectural state - top of stack
  * `add.zinc`
  * No operands - reads top of stack and accu implicitly, writes accu
  * No need to call into microcode - just a single cycle instruction
  * Other similar stack accessing ops
  </script></section>

</section>

<section>

  <section data-markdown><script type="text/template">
# Why not native code?

* Dynamic loading
* Compiler-libs
* REPL
* Bytecode part of OCaml compiler simpler than native code
  </script></section>

  <section data-markdown><script type="text/template">
# How about native code

* Can reuse some of the instruction set extensions mentioned
* Maybe there's a fast FPGA style architecture waiting to be found
  </script></section>

</section>

<section data-markdown><script type="text/template">
# License and packaging

* License?  BSD 
* Code is released using [OPAM](https://opam.ocaml.org)
* When will it be ready?  When its available in OPAM.
* I want it now!

```
$ opam pin add hardcaml-riscv https://github.com/ujamjar/hardcaml-riscv
$ opam install hardcaml-riscv
```
</script></section>

<section>

  <section data-markdown><script type="text/template">
# Thanks! Questions?

http://www.ujamjar.com/presentations/orconf2015.html

https://github.com/ujamjar/hardcaml

https://github.com/ujamjar/hardcaml-riscv

https://github.com/ujamjar/hardcaml-zinc

https://github.com/ujamjar/hardcaml-bloop

https://github.com/ujamjar/hardcaml-waveterm

https://github.com/ujamjar/hardcaml-llvmsim

https://github.com/ujamjar/hardcaml-vpi

  </script></section>

</section>

