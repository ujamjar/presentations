---
layout: presentation
title: ORCONF 2015 
description: OCaml and FPGAs
author: Andy Ray
---

<!-- Intro -->

<section data-markdown><script type="text/template">
# OCaml and FPGAs

### ORCONF 2015

Writing hardware in OCaml.  

Running OCaml in hardware.

andy.ray@ujamjar.com
</script></section>

<section data-markdown><script type="text/template">
# Topics

* __HardCaml__ RTL level hardware design as an embedded DSL in Ocaml
* __HardCaml-RISCV__ a simple pipelined RISC-V cpu written in HardCaml
* __HardCaml-ZINC__ extending the RISC-V core to implement the Ocaml ZINC bytecode instruction set
</script></section>

<!-- HardCaml -->

<section data-markdown><script type="text/template">
# HardCaml

* Structural RTL design.  
* mux, reg, select, and, or, xor, add, multiply etc
* Examples

```
type complex = { re : signal; im : signal }
let complex_multiply a b = {
  re = (a.re *+ b.re) -: (a.im *+ b.im);
  im = (a.re *+ b.im) +: (a.im *+ b.re);
}
```

```
let fir_filter taps enable x = 
  let f (p,v) tap = 
    let p = reg r_sync enable p in
    p, (p *: tap)
  in
  let x = List.fold_left f (x, zero (width x)) taps in
  tree 2 (reduce (+:) x)
```

</script></section>

<section>
  <section data-markdown><script type="text/template">
# Layered DSLs

* Build libraries to raise level of abstraction
  </script></section>

  <section data-markdown><script type="text/template">
* Guarded DSL - VHDL processes, Verilog always blocks
```
  let () = compile [
    sm [
      `wait, [
        cnt $==. (-1);
        msel $==. 0;
        g_when i.miss [
          msel $==. 1;
          maddr $== aligned_addr i.addr;
          caddr $== aligned_addr i.addr;
          g_if i.rw [
            (* read - load new cache line *)
            mreq $==. 1;
            next `load;
          ] [
            (* write *)
            g_if i.dirty [
              (* current cache line needs to be flushed *)
              maddr $== aligned_addr i.evict_addr;
  ....
```
  </script></section>

  <section data-markdown><script type="text/template">
* Recipes (monad reader issue 7, A Recipe for controlling Lego using Lava)
```
  let mult a_in b_in = 
    let open State in
    perform 
      (* create registers *)
      state <-- SState.newVar();
      (* set inputs and clear accumulator *)
      SState.apply (fun _ -> { a=a_in; b=b_in; acc=zero 8 }) state;
      (* serial multiplier *)
      SVar.while_ (fun b -> b <>:. 0) state.b 
        SState.(apply step state);
      (* return output *)
      acc <-- SVar.read state.acc;
      return acc
```
  </script></section>
  <section data-markdown><script type="text/template">
* Predicting the future...
* HardCaml-HLS
 * Imperative style DSL
 * Convert to SSA/Basic blocks
 * Binding, Clique Partitioning etc
 * Generate RTL
* HardCaml-GAA
 * Guarded Atomic Action DSL
  </script></section>
</section>

<section data-markdown><script type="text/template">
# Generate RTL

```
let circuit = Circuit.make "toplevel" [ list_of_outputs ]
let () = Rtl.Verilog.write print_string circuit
let () = Rtl.Vhdl.write print_string circuit
```
</script></section>

<section>
  <section data-markdown><script type="text/template">
# Simulation

* Cycle accurate simulation in OCaml

```
module Sim = HardCaml.Cyclesim.Make(B)
let testbench () = 
  let sim = Sim.make circuit
  clr := B.vdd;
  S.cycle sim;
  clr := B.gnd;
  ena := B.vdd;
  d := B.consti 32 12;
  S.cycle sim;
  printf "%i\n" (B.to_int !q);
```
  </script></section>
  <section data-markdown><script type="text/template">
# HardCaml-LLVMSIM

* Same API 
* __Much__ faster

```
module Sim = HardCamlLlvmsim.Sim.Make(B)
let () = testbench ()
```
  </script></section>
  <section data-markdown><script type="text/template">
# HardCaml-VPI

* Simulation performed by Icarus Verilog
* Same API
* Generates Verilog + testbench
* Interacts with OCaml testbench through a VPI object over sockets

```
module Sim = HardCaml.Cosim.Make(B)
let () = testbench ()
```
  </script></section>
</section>

<section>
  <section data-markdown><script type="text/template">
# Shallow or Deep 

* Combinatorial API is functorized
* type representing _combinatorial hardware_ can be shallow or deep
* Shallow
  * Hardware represented as values ie int list
  * Great for exploring combinatorial logic in REPL
* Deep
  * Hardware represented as an AST.  
  * Required for simulation or RTL generation
* Only deep embedding for sequential logic
  </script></section>

  <section data-markdown><script type="text/template">
# Shallow

```
        OCaml version 4.02.1

# #use "topfind";;
# #require "hardcaml";;
# open HardCaml.Api.B;;
# (const "01") +: (const "10");;
- : HardCaml.Api.B.t = [1; 1]
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : HardCaml.Api.B.t = [0; 0; 0; 1; 0; 0; 0; 0]
```
  </script></section>

  <section data-markdown><script type="text/template">
# Deep

```
# open HardCaml.Api.Comb;;
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : HardCaml.Api.Comb.t =
HardCaml.Signal.Types.Signal_op
 ({HardCaml.Signal.Types.s_id = 43L; s_names = []; s_width = 8;
   s_deps =
    [HardCaml.Signal.Types.Signal_op
      ({HardCaml.Signal.Types.s_id = 42L; s_names = []; s_width = 8;
        s_deps =
         [HardCaml.Signal.Types.Signal_op
           ({HardCaml.Signal.Types.s_id = 41L; s_names = []; s_width = 8;
             s_deps =
              [HardCaml.Signal.Types.Signal_const
                ({HardCaml.Signal.Types.s_id = 37L; s_names = [];
                  s_width = 8; s_deps = []},
                "00000001");
               HardCaml.Signal.Types.Signal_const
                ({HardCaml.Signal.Types.s_id = 38L; s_names = [];
                  s_width = 8; s_deps = []},
                "00000010")]},
           HardCaml.Signal.Types.Signal_add);
          HardCaml.Signal.Types.Signal_const
           ({HardCaml.Signal.Types.s_id = 39L; s_names = []; s_width = 8;
             s_deps = []},
           "00000011")]},
      HardCaml.Signal.Types.Signal_add);
     HardCaml.Signal.Types.Signal_const
      ({HardCaml.Signal.Types.s_id = 40L; s_names = []; s_width = 8;
        s_deps = []},
      "00001010")]},
 HardCaml.Signal.Types.Signal_add)
```
  </script></section>

  <section data-markdown><script type="text/template">
# Xilinx LUTs

* Same code, different functors, very different results.

```
# open HardCaml.Xilinx;;
# module X = HardCaml.Comb.Make( XComb( XMake(Unisim)(Lut4) ) );;
# open X;;
# reduce (+:) (List.map (consti 8) [1;2;3;10]);;
- : X.t =
HardCaml.Signal.Types.Signal_op
 ({HardCaml.Signal.Types.s_id = 610L; s_names = []; s_width = 8;
   s_deps =
    [HardCaml.Signal.Types.Signal_inst
      ({HardCaml.Signal.Types.s_id = 607L; s_names = []; s_width = 1;
        s_deps =
        ...
# HardCaml.Rtl.Verilog.write print_string @@ HardCaml.Circuit.make "xadd" [ output "q" (reduce (+:) (List.map (consti 8) [1;2;3;10])) ];;
...
    assign _810 = _809[0:0];
    LUT2
        #( .INIT("0110") )
        the_LUT2_22
        ( .I0(_810), .I1(_811), .O(_813[0:0]) );
    assign _793 = _614[0:0];
    MUXCY
        the_MUXCY_13
        ( .CI(gnd), .DI(_793), .S(_813), .O(_817[0:0]) );
...
```
  </script></section>

</section>

<!-- HardCaml-RISCV -->

<section data-markdown><script type="text/template">
# HardCaml-RISCV
</script></section>

<!-- HardCaml-ZINC -->

<section data-markdown><script type="text/template">
# HardCaml-ZINC
</script></section>



